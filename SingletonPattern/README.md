# Singleton Pattern

## 模式动机

- 对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。
- 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。
- 一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。

## 模式定义
- 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
- 单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。

## 实现方式

- 懒汉模式

1. 使用懒汉模式时，Singleton在程序第一次调用的时候才会初始化自己。
2. 使用该模式时，由于if语句的存在，会影响调用的效率。
3. 而且，在多线程环境下使用时，为了保证只能初始化一个实例，需要用锁来保证线程安全性，
4. 如果遇到处理大量数据时，锁会成为整个性能的瓶颈。

- 饿汉模式

1. 饿汉模式比较适用于程序整个运行过程中都需要访问、会被频繁访问或者需要被多线程访问的情况。
2. 饿汉模式适用于Singleton被频繁调用，这样由于预先加载了实例，访问实例时没有if语句，效率更高。
3. 但是，如果Singleton的成员比较庞大，复杂，实例化Singleton会花一些时间，且这个实例一直占用着大量内存。在使用时要注意这部分的开销。
4. 使用饿汉模式用于多线程编程中，由于线程访问之前，实例已经存在，就不需要像懒汉模式 中加入锁。
5. 因此 饿汉模式保证了多线程安全。

## 参考
https://www.tianmaying.com/tutorial/singleton
http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html